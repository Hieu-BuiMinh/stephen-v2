---
id: '3d420fc4-5b75-4c41-9319-9e4a1bdb7a1c'
title: 'CSR, SSR, SSG, and ISR in Next.js'
cover: '/assets/articles/dev/post/nextjs-rendering-strategies.png'
createdAt: '2025-08-12T00:00:00Z'
description: A practical guide to CSR, SSR, SSG, and ISR in Next.js 14/15 using the App Router with TypeScript—when to use each, pros/cons, and working examples.
published: true
hashTags: ['dev', 'post', 'nextjs', 'typescript']
type: 'post'
---

Next.js supports multiple rendering strategies to help you optimize **performance**, **SEO**, and **user experience**. The four most common ones are **CSR**, **SSR**, **SSG**, and **ISR**.

This guide focuses on **Next.js 14/15** with the **App Router** (`app/`) and **TypeScript**. You'll see when to use **CSR**, **SSR**, **SSG**, and **ISR**, their pros and cons.

## 1. CSR - Client-Side Rendering (App Router)

**How it works:**

- The server sends a mostly empty HTML shell.
- The browser downloads JavaScript, then fetches data on the client and renders the content dynamically.

In Next js UI renders first, then data is fetched in the **browser**. Use a **Client Component** (`'use client'`).

<CodeBlockTabs options={["App Router", "Pages Router"]}>

```tsx
// app/client-example/page.tsx
'use client' // [!code hl]
import { useEffect, useState } from 'react'

type ApiData = { message: string }

export default function ClientPage() {
	const [data, setData] = useState<ApiData | null>(null)

	useEffect(() => {
		fetch('/api/data')
			.then((r) => r.json() as Promise<ApiData>)
			.then(setData)
	}, [])

	if (!data) return <p>Loading...</p>
	return <div>{data.message}</div>
}
```

```tsx
// pages/index.tsx
import { useEffect, useState } from 'react'

type ApiData = { message: string }

export default function Page() {
	const [data, setData] = useState<ApiData | null>(null)

	useEffect(() => {
		fetch('/api/data')
			.then((r) => r.json() as Promise<ApiData>)
			.then(setData)
	}, [])

	if (!data) return <p>Loading...</p>
	return <div>{data.message}</div>
}
```

</CodeBlockTabs>

**When to use:**

- Data is user-specific: Dashboards/internal tools, post-login areas.
- Personalization that can happen in the browser or heavy interactivity.
- SEO is not required for the changing parts.

**Pros:**

- Lighter server load.
- Great for highly interactive UIs.
- Easy client-side state management.

**Cons:**

- Poor SEO (content isn't ready at first load).
- Slower “first content” because rendering waits for JavaScript.

## 2. SSR - Server-Side Rendering (App Router)

**How it works:**

- On every request, the server fetches data and renders a full HTML page.
- The HTML is sent to the browser already containing the content.

The page is rendered on the **server for each request**. In App Router, you typically fetch with `cache: 'no-store'` or mark the route dynamic.

<CodeBlockTabs options={["App Router", "Pages Router"]}>

```tsx
// app/ssr-example/page.tsx
import type { Metadata } from 'next'

type ApiData = { message: string }

async function getData(): Promise<ApiData> {
	const res = await fetch('https://api.example.com/data', {
		cache: 'no-store', // [!code hl]
	})
	return res.json()
}

// Optional but recommended for SEO in App Router:
export async function generateMetadata(): Promise<Metadata> {
	const data = await getData() // [!code hl]
	return {
		title: `${data.message} | My Site`,
		description: `Up-to-date information about ${data.message}.`,
		openGraph: {
			title: `${data.message} | My Site`,
			description: `Up-to-date information about ${data.message}.`,
			type: 'website',
		},
	}
}

export default async function Page() {
	const data = await getData() // [!code hl]
	return <div>{data.message}</div>
}
```

```tsx
// pages/index.tsx
import type { GetServerSideProps, InferGetServerSidePropsType } from 'next'

type ApiData = { message: string }

export const getServerSideProps: GetServerSideProps<{ data: ApiData }> = async () => {
	// [!code hl]
	const res = await fetch('https://api.example.com/data')
	const data = (await res.json()) as ApiData
	return { props: { data } }
}

export default function Page({ data }: InferGetServerSidePropsType<typeof getServerSideProps>) {
	return <div>{data.message}</div>
}
```

</CodeBlockTabs>

**When to use:**

- Data changes on every request (e.g., personalized content, real-time dashboards).
- You want strong SEO for dynamic content.

**Pros:**

- Excellent SEO (full HTML + metadata sent from server).
- Always fresh data per request.

**Cons:**

- Slower than SSG/ISR; higher server cost.

## 3. SSG - Static Site Generation (App Router)

**How it works:**

- Pages are pre-rendered at build time into static HTML files.
- Content is fixed until the next build.

HTML is **pre-rendered at build time**. In App Router, this is the **default** when nothing forces dynamic behavior. You can be explicit with `force-static` or cache the fetch.

<CodeBlockTabs options={["App Router", "Pages Router"]}>

```tsx
// app/ssg-example/page.tsx
export const dynamic = 'force-static' // optional, makes intent explicit // [!code hl]

type ApiData = { message: string }

async function getData(): Promise<ApiData> {
	// default is 'force-cache' in static routes
	const res = await fetch('https://api.example.com/data', {
		cache: 'force-cache', // [!code hl]
	})
	return res.json()
}

export default async function Page() {
	const data = await getData() // [!code hl]
	return <div>{data.message}</div>
}
```

```tsx
// pages/index.tsx
import type { GetStaticProps, InferGetStaticPropsType } from 'next'

type ApiData = { message: string }

export const getStaticProps: GetStaticProps<{ data: ApiData }> = async () => {
	// [!code hl]
	const res = await fetch('https://api.example.com/data')
	const data = (await res.json()) as ApiData
	return { props: { data } }
}

export default function Page({ data }: InferGetStaticPropsType<typeof getStaticProps>) {
	return <div>{data.message}</div>
}
```

</CodeBlockTabs>

**When to use:**

- Content changes rarely (docs, marketing, evergreen blog posts).

**Pros:**

- Super fast (served from CDN).
- Almost zero server cost.

**Cons:**

- Requires a rebuild to update content.

## 4. ISR - Incremental Static Regeneration (App Router)

**How it works:**

- A hybrid between SSG and SSR.
- Pages are pre-rendered like SSG, but Next.js can regenerate them in the background after a set revalidate time.

Like SSG, but the page **regenerates in the background** on an interval. In App Router, use the `revalidate` export or per-request `fetch` option.

<CodeBlockTabs options={["App Router", "Pages Router"]}>

```tsx
// app/isr-example/page.tsx
export const revalidate = 60 // seconds // optional // [!code hl]

type ApiData = { message: string }

async function getData(): Promise<ApiData> {
	// You can also do per-request control:
	// fetch(url, { next: { revalidate: 60 } })
	const res = await fetch('https://api.example.com/data', {
		next: { revalidate: 60 }, // [!code hl]
	})
	return res.json()
}

export default async function Page() {
	const data = await getData() // [!code hl]
	return <div>{data.message}</div>
}
```

```tsx
// pages/index.tsx
import type { GetStaticProps, InferGetStaticPropsType } from 'next'

type ApiData = { message: string }

export const getStaticProps: GetStaticProps<{ data: ApiData }> = async () => {
	const res = await fetch('https://api.example.com/data')
	const data = (await res.json()) as ApiData
	return {
		props: { data },
		revalidate: 60, // seconds // [!code hl]
	}
}

export default function Page({ data }: InferGetStaticPropsType<typeof getStaticProps>) {
	return <div>{data.message}</div>
}
```

</CodeBlockTabs>

**When to use:**

- Data updates, but **not** strictly real-time (blogs, listings, catalogs).

**Pros:**

- Near-SSG speed with periodic freshness.
- CDN-friendly, lower server cost than SSR.

**Cons:**

- There can be a short “stale” window before regeneration.
- Not instantly up-to-date (freshness tied to interval).
- Requires platform support for on-demand/background regeneration.

## Migration table (Pages Router → App Router)

Use this table to migrate from `pages/` APIs to the App Router equivalents in Next.js 14/15.

| Goal           | Pages Router (`pages/`)         | App Router (`app/`)                                                                            |
| -------------- | ------------------------------- | ---------------------------------------------------------------------------------------------- |
| **SSR**        | `getServerSideProps`            | `fetch(url, { cache: 'no-store' })` **or** `export const dynamic = 'force-dynamic'`            |
| **SSG**        | `getStaticProps`                | Default static, optionally `export const dynamic = 'force-static'`                             |
| **ISR**        | `getStaticProps` + `revalidate` | `export const revalidate = <seconds>` **or** `fetch(url, { next: { revalidate: <seconds> } })` |
| **SEO meta**   | `<Head>`                        | `export async function generateMetadata()`                                                     |
| **Route data** | `getStaticPaths`                | `generateStaticParams()`                                                                       |
| **Caching**    | Manual/headers                  | `fetch` cache options (`force-cache`, `no-store`), route-level `revalidate`                    |
| **Edge**       | `runtime: 'edge'` in pages      | Route Handlers / `export const runtime = 'edge'`                                               |

## Practical tips for Next 14/15

- **Force SSR**: `fetch(url, { cache: 'no-store' })` or `export const dynamic = 'force-dynamic'`.
- **Force SSG**: avoid dynamic functions; optionally `export const dynamic = 'force-static'`.
- **ISR**: `export const revalidate = <seconds>` (at file level) **or** `fetch(url, { next: { revalidate: <seconds> } })`.
- **SEO (App Router)**: Prefer `generateMetadata()` over `<Head />`.
- **Client Components**: add `'use client'` at the top and keep server-only APIs out of them.
- **Static params for dynamic routes**: use `generateStaticParams()` to prebuild `[slug]` pages.

---

## Conclusion

- **CSR** for post-login/app-like experiences.
- **SSR** when you need request-aware or always-fresh content with strong SEO.
- **SSG** for stable content; fastest and cheapest.
- **ISR** balances speed and freshness without full rebuilds.
