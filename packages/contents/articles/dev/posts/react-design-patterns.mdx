---
id: 'cd63c0b8-2f11-4773-b362-372a43e31f73'
title: 'React Design Patterns - A Friendly Guide'
cover: '/assets/articles/dev/post/react-design-patterns.png'
createdAt: '2025-11-21T03:14:27.130Z'
description: Explore React design patterns and examine how they might improve the development of React applications
published: true
hashTags: ['dev', 'post', 'ts', 'react-js']
type: 'post'
---

When you first learn React, everything feels like components, props, and state. But as your app grows, you quickly hit questions like:

- "Where should I keep this state?"
- "Why is this component so fat?"
- "How do I reuse this logic without copy-paste?"

This is where design patterns come in. They are not magic rules, just common ways to organize components and logic so your code stays clean and easy to maintain.

In this post, we'll walk through the most useful React patterns, grouped into 4 categories:

-   1. Component patterns
-   2. State management patterns
-   3. Rendering & performance patterns
-   4. Architectural patterns

You don't need to memorize all of them. Just read, get the idea, and later you'll recognize:

> Oh, I'm actually using the Container/Presentational pattern here!

## 1. Component Patterns

### 1.1 Presentational vs Container Components

<u>Problem</u>: Your component does everything - fetches data, holds state, and renders UI. It becomes hard to test and
reuse.

<u>Idea</u>: Split into two types - Container Component:

- Knows how things work
- Fetches data, handles state, calls APIs

- Presentational Component:
    - Knows how things look
    - Receives props and renders UI only

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useEffect, useState } from 'react'

interface User {
	id: number
	name: string
}

interface UserListProps {
	users: User[]
}

// Presentational: only UI
const UserList: React.FC<UserListProps> = ({ users }) => {
	return (
		<ul>
			{users.map((u) => (
				<li key={u.id}>{u.name}</li>
			))}
		</ul>
	)
}

// Container: fetches data, owns state
const UserListContainer: React.FC = () => {
	const [users, setUsers] = useState<User[]>([])

	useEffect(() => {
		fetch('/api/users')
			.then((res) => res.json())
			.then((data: User[]) => setUsers(data))
	}, [])

	return <UserList users={users} />
}

export default UserListContainer
```

</CodeBlockTabs>

<u>Why it's good</u>:

- Easier to test UI separately
- You can reuse `<UserList>` with any data source

### 1.2 Controlled vs Uncontrolled Components

<u>Problem</u>: How should you handle forms and inputs? Inside React or just let the DOM manage them?

<u>Controlled component</u>:

- React state is the single source of truth
- Input value comes from state, and changes go through `onChange`

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useState, ChangeEvent } from 'react'

const NameInput: React.FC = () => {
	const [name, setName] = useState('')

	const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
		setName(e.target.value)
	}

	return <input value={name} onChange={handleChange} />
}
```

</CodeBlockTabs>

<u>Uncontrolled component</u>:

- The DOM manages the value
- You read it only when needed using a `ref`

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useRef } from 'react'

const NameForm: React.FC = () => {
	const inputRef = useRef<HTMLInputElement | null>(null)

	const handleSubmit = () => {
		if (inputRef.current) {
			alert(inputRef.current.value)
		}
	}

	return (
		<>
			<input ref={inputRef} />
			<button onClick={handleSubmit}>Submit</button>
		</>
	)
}
```

</CodeBlockTabs>

<u>Rule of thumb</u>:

- Use controlled when you need validation, instant feedback, or complex logic
- Use uncontrolled for simple forms, or when performance is critical

### 1.3 Compound Components

<u>Problem</u>: You want a flexible component like `<Tabs>` or `<Dropdown>` where users can control the structure but still share internal state.

<u>Idea</u>: Create a "parent" component and several "child" components that talk via React Context.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { createContext, useContext, useState, ReactNode, FC } from 'react'

interface TabsContextValue {
	active: string
	setActive: (id: string) => void
}

const TabsContext = createContext<TabsContextValue | undefined>(undefined)

const useTabsContext = (): TabsContextValue => {
	const ctx = useContext(TabsContext)
	if (!ctx) throw new Error('Tabs.* must be used inside <Tabs>')
	return ctx
}

interface TabsProps {
	defaultTab: string
	children: ReactNode
}

export const Tabs: FC<TabsProps> = ({ defaultTab, children }) => {
	const [active, setActive] = useState(defaultTab)

	return <TabsContext.Provider value={{ active, setActive }}>{children}</TabsContext.Provider>
}

interface TabListProps {
	children: ReactNode
}

export const TabList: FC<TabListProps> = ({ children }) => {
	return <div>{children}</div>
}

interface TabProps {
	id: string
	children: ReactNode
}

export const Tab: FC<TabProps> = ({ id, children }) => {
	const { active, setActive } = useTabsContext()
	const isActive = active === id

	return (
		<button style={{ fontWeight: isActive ? 'bold' : 'normal' }} onClick={() => setActive(id)}>
			{children}
		</button>
	)
}

interface TabPanelProps {
	when: string
	children: ReactNode
}

export const TabPanel: FC<TabPanelProps> = ({ when, children }) => {
	const { active } = useTabsContext()
	if (active !== when) return null
	return <div>{children}</div>
}

// Usage
/*
<Tabs defaultTab="profile">
  <TabList>
    <Tab id="profile">Profile</Tab>
    <Tab id="settings">Settings</Tab>
  </TabList>

  <TabPanel when="profile">Profile content</TabPanel>
  <TabPanel when="settings">Settings content</TabPanel>
</Tabs>
*/
```

</CodeBlockTabs>

<u>Benefit</u>: Users can compose your UI like Lego, but still get shared logic and state.

### 1.4 Higher-Order Components (HOC) - Typed

> NOTE: Today, hooks are preferred, but HOCs are still seen in older codebases.

<u>Idea</u>: A function that takes a component and returns a new one with extra props/logic.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React from 'react'

interface WithLoadingProps {
	isLoading: boolean
}

export function withLoading<P extends object>(Wrapped: React.ComponentType<P>) {
	const ComponentWithLoading: React.FC<P & WithLoadingProps> = ({ isLoading, ...props }) => {
		if (isLoading) return <div>Loading...</div>
		return <Wrapped {...(props as P)} />
	}

	return ComponentWithLoading
}
```

</CodeBlockTabs>

Good to know, but for new code, prefer custom hooks.

### 1.5 Render Props

<u>Problem</u>: You want to share logic, but let the consumer decide how to render UI.

<u>Idea</u>: Pass a function as a prop or as children, and call it from inside your component.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useState, MouseEvent, ReactNode } from 'react'

interface Position {
	x: number
	y: number
}

interface MouseTrackerProps {
	children: (pos: Position) => ReactNode
}

const MouseTracker: React.FC<MouseTrackerProps> = ({ children }) => {
	const [pos, setPos] = useState<Position>({ x: 0, y: 0 })

	const handleMove = (e: MouseEvent<HTMLDivElement>) => {
		setPos({ x: e.clientX, y: e.clientY })
	}

	return (
		<div onMouseMove={handleMove} style={{ height: 200, background: '#eee' }}>
			{children(pos)}
		</div>
	)
}

// Usage
/*
<MouseTracker>
  {({ x, y }) => <p>Mouse: {x}, {y}</p>}
</MouseTracker>
*/
```

</CodeBlockTabs>

Again, in modern React, this pattern is often replaced by…

### 1.6 Hooks Patterns (Custom Hooks & Composition)

<u>Idea</u>: Put reusable logic into custom hooks like useSomething() and reuse them in different components.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import { useCallback, useState } from 'react'

export const useToggle = (initial = false): [boolean, () => void] => {
	const [value, setValue] = useState<boolean>(initial)
	const toggle = useCallback(() => setValue((v) => !v), [])
	return [value, toggle]
}

// Usage
/*
const [isOpen, toggleOpen] = useToggle(false);
*/
```

</CodeBlockTabs>

You can compose hooks inside other hooks:

<CodeBlockTabs fileName='index.tsx'>

```tsx
import { useEffect, useState } from 'react'

interface UserProfile {
	id: number
	name: string
}

interface UseUserProfileResult {
	user: UserProfile | null
	loading: boolean
}

export const useUserProfile = (userId: number): UseUserProfileResult => {
	const [user, setUser] = useState<UserProfile | null>(null)
	const [loading, setLoading] = useState<boolean>(true)

	useEffect(() => {
		setLoading(true)
		fetch(`/api/users/${userId}`)
			.then((res) => res.json())
			.then((data: UserProfile) => {
				setUser(data)
				setLoading(false)
			})
	}, [userId])

	return { user, loading }
}
```

</CodeBlockTabs>

Custom hooks are the modern core pattern for logic reuse in React.

## 2. State Management Patterns

### 2.1 Lifting State Up

<u>Problem</u>: Two sibling components need to share some data and keep it in sync.

<u>Bad approach</u>: Each one has its own state → they get out of sync.

<u>Idea</u>: Move the state up into their common parent, pass it down via props.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useState, ChangeEvent } from 'react'

interface InputProps {
	value: string
	onChange: (value: string) => void
}

const Input: React.FC<InputProps> = ({ value, onChange }) => {
	const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
		onChange(e.target.value)
	}

	return <input value={value} onChange={handleChange} />
}

interface PreviewProps {
	value: string
}

const Preview: React.FC<PreviewProps> = ({ value }) => {
	return <p>Preview: {value}</p>
}

const Parent: React.FC = () => {
	const [value, setValue] = useState('')

	return (
		<>
			<Input value={value} onChange={setValue} />
			<Preview value={value} />
		</>
	)
}
```

</CodeBlockTabs>

### 2.2 Global State via Context or Store Libraries

<u>Problem</u>: Some state is needed by many components in different parts of the tree (theme, user, cart, settings…).

<u>Idea</u>: Store this state in a Context or external store (Redux, Zustand, Jotai, etc.), and consume it wherever
needed.

Simple Context example:

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { createContext, useContext, useState, ReactNode, FC } from 'react'

interface ThemeContextValue {
	dark: boolean
	toggle: () => void
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined)

const useTheme = (): ThemeContextValue => {
	const ctx = useContext(ThemeContext)
	if (!ctx) throw new Error('useTheme must be used within ThemeProvider')
	return ctx
}

interface ThemeProviderProps {
	children: ReactNode
}

export const ThemeProvider: FC<ThemeProviderProps> = ({ children }) => {
	const [dark, setDark] = useState(false)

	const toggle = () => setDark((d) => !d)

	return <ThemeContext.Provider value={{ dark, toggle }}>{children}</ThemeContext.Provider>
}

export const ThemeSwitcher: FC = () => {
	const { dark, toggle } = useTheme()
	return <button onClick={toggle}>Theme: {dark ? 'Dark' : 'Light'}</button>
}
```

</CodeBlockTabs>

For larger apps, you might use Redux or other libraries to handle more complex global logic.

### 2.3 State Machine / Statechart Pattern

<u>Problem</u>: You have complex states and transitions, like

- idle → loading → success / error
- multiple nested and parallel states

It becomes hard to manage with just `if` and `useState`.

<u>Idea</u>: Model your logic as a state machine

- Define allowed states
- Define valid transitions between them

Often implemented with libraries like XState.

Even without a library, you can structure code like:

<CodeBlockTabs fileName='index.tsx'>

```tsx
import { useCallback, useState } from 'react'

type RequestStatus = 'IDLE' | 'LOADING' | 'SUCCESS' | 'ERROR'

interface UseRequestResult<T> {
	status: RequestStatus
	data: T | null
	run: () => void
}

export const useRequest = <T,>(url: string): UseRequestResult<T> => {
	const [status, setStatus] = useState<RequestStatus>('IDLE')
	const [data, setData] = useState<T | null>(null)

	const run = useCallback(() => {
		setStatus('LOADING')
		fetch(url)
			.then((res) => res.json())
			.then((d: T) => {
				setData(d)
				setStatus('SUCCESS')
			})
			.catch(() => {
				setStatus('ERROR')
			})
	}, [url])

	return { status, data, run }
}
```

</CodeBlockTabs>

## 3. Rendering & Performance Patterns

### 3.1 Code Splitting & Lazy Loading

<u>Problem</u>: Your bundle is huge, users download everything even if they never visit some routes.

<u>Idea</u>: Split your code into chunks and load them only when needed using `React.lazy` and `Suspense`.

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { Suspense } from 'react'
import { Routes, Route } from 'react-router-dom'

const SettingsPage = React.lazy(() => import('./SettingsPage'))

const App: React.FC = () => {
	return (
		<Suspense fallback={<div>Loading…</div>}>
			<Routes>
				<Route path="/settings" element={<SettingsPage />} />
			</Routes>
		</Suspense>
	)
}

export default App
```

</CodeBlockTabs>

### 3.2 Memoization Patterns (`React.memo`, `useMemo`, `useCallback`)

<u>Problem</u>: Components re-render too often, slowing things down.

<u>Tools</u>:

- `React.memo(Component)` → avoid re-render if props didn't change
- `useMemo` → cache expensive calculations
- `useCallback` → cache functions so child components don't re-render unnecessarily

<CodeBlockTabs fileName='index.tsx'>

```tsx
import React, { useMemo } from 'react'

interface Item {
	id: number
	name: string
}

interface ItemListProps {
	items: Item[]
}

const ItemList: React.FC<ItemListProps> = React.memo(({ items }) => {
	console.log('render ItemList')
	return (
		<>
			{items.map((i) => (
				<div key={i.id}>{i.name}</div>
			))}
		</>
	)
})

interface PageProps {
	items: Item[]
}

const Page: React.FC<PageProps> = ({ items }) => {
	const sorted = useMemo(() => [...items].sort((a, b) => a.name.localeCompare(b.name)), [items])

	return <ItemList items={sorted} />
}
```

</CodeBlockTabs>

Use them carefully - overusing memoization can make code harder to understand without real perf benefits.

### 3.3 List Virtualization

<u>Problem</u>: You render 10,000 items in a list and your app becomes slow.

<u>Idea</u>: Render only what the user sees on screen. As they scroll, items are recycled.

This is usually done with libraries like:

- `react-window`
- `react-virtualized`

Conceptually:

<CodeBlockTabs fileName='index.tsx'>

```tsx
<VirtualizedList itemCount={10000} itemHeight={32} renderItem={({ index }) => <Row index={index} />} />
```

</CodeBlockTabs>

Great for dashboards, logs, chat history, etc.

## 4. Architectural Patterns

These patterns are more about how you organize your project than individual components.

### 4.1 Smart vs Dumb Components (Revisited at Architecture Level)

We saw this before:

- Smart (Container): connect to APIs/state, pass props down.
- Dumb (Presentational): only UI.

At the project level, you might decide:

- pages/ or screens/ → smart components
- components/ → mostly dumb, reusable components

This keeps your UI layer clean and reusable.

### 4.2 Feature-Based Folder Structure

<u>Problem</u>: Classic structure like this becomes messy as the app grows:

<CodeBlockTabs fileName='bash'>

```bash
components/
pages/
hooks/
utils/
```

</CodeBlockTabs>

You never know where to put new files.

<u>Idea</u>: Group everything by feature, not by type.

<CodeBlockTabs fileName='bash'>

```bash
src/
  features/
    auth/
      components/
      hooks/
      api/
    cart/
      components/
      hooks/
      api/
  shared/
    components/
    hooks/
    utils/
```

</CodeBlockTabs>

This way, if you work on the cart feature, everything is in one place.

### 4.3 Layered / "Clean-ish" Architecture

<u>Goal</u>: Separate concerns so that:

- UI doesn't know about data fetching details
- Business logic can be tested without React

A simple version:

- ui/ - components, pages
- hooks/ - custom hooks for business logic
- services/ - API calls, data access
- models/ - data types, domain logic

<CodeBlockTabs fileName='bash'>

```bash
UI (components/pages)
   ↓
Hooks (useUserProfile, useCart)
   ↓
Services (userService, cartService)
   ↓
API / Models (fetch, axios, types)
```

</CodeBlockTabs>

Even if you don't fully follow "Clean Architecture", thinking in layers keeps code from turning into spaghetti.

---

## Final Thoughts

React doesn't come with an official list of "10 canonical design patterns".

Instead, the community has discovered useful ways to structure components, state, and files that solve common problems.

You don't need to use all patterns at once. A good path might be:

-   1. Start with Presentational/Container and lifting state up
-   2. Learn custom hooks to reuse logic
-   3. Use Context or a store when state becomes global
-   4. Improve performance with lazy loading and memoization
-   5. As the app grows, refactor into feature-based folders and clearer layers

If you want, I can:

- Turn this post into a shorter LinkedIn/Facebook version, or
- Add more code samples for any pattern and tailor them to your actual project.
